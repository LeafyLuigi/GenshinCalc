<!DOCTYPE html>
<html>
	<head>
		<title>Genshin Calculator - Debug Page</title>
		<link rel="stylesheet" href="style.css">
		<script type="text/javascript" src="chardb.js"></script>
		<script type="text/javascript" src="itemdb.js"></script>
		<script type="text/javascript" src="weapdb.js"></script>
		<script type="text/javascript" src="artifactdb.js"></script>
		<script type="text/javascript" src="ascdb.js"></script>
		<script type="text/javascript" src="scripts.js"></script>
		<script type="text/javascript" src="scripts/cookieLocalStorage.js"></script>
		<script type="text/javascript" src="scripts/inventory.js"></script>
		<script type="text/javascript" src="scripts/charWeapHandling.js"></script>
		<style>
			h1,h2,h3,h4,h5,h6 {
				margin-block-end: 0;
			}
			h2 + div h3 {
				margin-block-start: 0;
			}
			:is(h2,h3):only-child::after {
				content: " No issues!";
			}
			.includeFalse::before {
				content: "⚠️ ";
			}
		</style>
	</head>
	<body>
		<h1>This is a debug page for testing.</h1>
		<div id="characters"><h2>Characters:</h2></div>
		<div id="items"><h2>Items:</h2></div>
		<div id="itemGroups"><h2>Item Groups:</h2></div>
		<div id="weapons"><h2>Weapons:</h2></div>
		<div id="artifacts"><h2>Artifacts:</h2></div>
		<div><h2>Include: false Images:</h2><div id="imageErrorsIncludeFalse"><h3>Errors:</h3></div><div id="imagesIncludeFalse" style="display:flex;flex-flow:row wrap"></div></div>
		<div><h2>Other Images:</h2><div id="imageErrors"><h3>Errors:</h3></div><div id="images" style="display:flex;flex-flow:row wrap"></div></div>
	</body>
	<script>
	"use strict";
	pageType = "debug";
	window.addEventListener("load", () => {
		let visions = [];
		// Characters
		for(let i in chars) {
			let c = chars[i];
			let issues = [];
			let included = true;
			if(c.rarity !== 5 && c.rarity !== 4) {
				issues.push(" rarity is not 4 or 5");
			}
			if(c.weapon === undefined) {
				issues.push(" weapon missing");
			} else if(allWeaponTypes.indexOf(c.weapon) === -1) {
				issues.push(" weapon invalid");
			}
			if(c.boss === undefined) {
				issues.push(" boss missing");
			} else if (itemDB[c.boss] === undefined && c.boss !== null) {
				issues.push(" boss invalid");
				if(c.boss != "Unknown" && c.boss !== null) {
					dp(c.boss+" does not exist (used by char "+i+")","items");
				}
			}
			if(c.gem === undefined) {
				issues.push(" gem missing");
			} else if (itemGroupDB[c.gem] === undefined && c.gem !== null) {
				issues.push(" gem invalid");
				if(c.gem != "Unknown" && c.gem !== null) {
					dp(c.gem+" does not exist (used by char "+i+")","items");
				}
			}
			if(c.local === undefined) {
				issues.push(" local missing");
			} else if (itemDB[c.local] === undefined) {
				issues.push(" local invalid");
				if(c.local != "Unknown") {
					dp("\""+c.local+"\" does not exist (used by char "+i+")","items");
				}
			}
			if(c.common === undefined) {
				issues.push(" common missing");
			} else if (itemGroupDB[c.common] === undefined) {
				issues.push(" common invalid");
				if(c.common != "Unknown") {
					dp("\""+c.common+"\" does not exist (used by char "+i+")","items");
				}
			}
			if(c.canRename !== true && c.canRename !== undefined) {
				issues.push(" invalid canRename (must be true or undefined)");
			}

			if(c.include !== false && c.include !== undefined) {
				issues.push(" include invalid (must be false or undefined)");
				dimg("char/"+spaceToUnderscore(i)+".png","imagesIncludeFalse");
				included = false;
			} else if (c.include === false) {
				issues.push(" include is false (remove it to allow usage)");
				included = false;
				dimg("char/"+spaceToUnderscore(i)+".png","imagesIncludeFalse");
			} else {
				dimg("char/"+spaceToUnderscore(i)+".png","images");
			}

			if(i != "Traveler") {
				if(c.region === undefined) {
					issues.push(" region missing");
				} else if (charRegions.indexOf(c.region) === -1) {
					issues.push(" region invalid");
				}
				if(c.weeklyBoss === undefined) {
					issues.push(" weeklyBoss missing");
				} else if (itemDB[c.weeklyBoss] === undefined) {
					issues.push(" weeklyBoss invalid");
					if(c.weeklyBoss != "Unknown") {
						dp("\""+c.weeklyBoss+"\" does not exist (used by char "+i+")","items");
					}
				}
				if(c.books === undefined) {
					issues.push(" books missing");
				} else if (itemGroupDB[c.books] === undefined) {
					issues.push(" books invalid");
					if(c.books != "Unknown") {
						dp("Group \""+c.books+"\" does not exist (used by char "+i+")","itemGroups");
					}
				}
				if(c.hasCons !== false && c.hasCons !== undefined) {
					issues.push(" invalid hasCons (must be false or undefined)");
				}
				if(c.hasCons === false) {
					if(c.conBonus !== undefined) {
						issues.push(" conBonus exists while hasCons is false");
					}
				} else if(c.hasCons === undefined) {
					if(typeof(c.conBonus) === "string") {
						issues.push(" conBonus has type string when it must be object (format {\"1|2|3\":<conLevel>,\"1|2|3\":<conLevel>})");
					} else {
						if(Object.keys(c.conBonus).length > 2) {
							issues.push(" conBonus keys length is more than 2");
						}
					}
				}
				if(c.type === undefined) {
					issues.push(" type missing");
				} else if (charTypes.indexOf(c.type) === -1) {
					issues.push(" type invalid");
				}

				if(c.vision !== undefined) {
					if(visions.indexOf(c.vision) === -1) {
						visions.push(c.vision);
					}
				}
			} else {
				let cr = c.regions;
				for(let i in cr) {
					let c = cr[i];
					if(c.region === undefined) {
						issues.push(" [regions/"+i+"] region missing");
					} else if (charRegions.indexOf(c.region) === -1) {
						issues.push(" [regions/"+i+"] region invalid");
					}
					if(c.type === undefined) {
						issues.push(" [regions/"+i+"] type missing");
					} else if (charTypes.indexOf(c.type) === -1) {
						issues.push(" [regions/"+i+"] type invalid");
					}
					if(c.hasCons !== false && c.hasCons !== undefined) {
						issues.push(" [regions/"+i+"] invalid hasCons (must be false or undefined)");
					}
					if(c.hasCons === false) {
						if(c.conBonus !== undefined) {
							issues.push(" [regions/"+i+"] conBonus exists while hasCons is false");
						}
					} else if(c.hasCons === undefined) {
						if(typeof(c.conBonus) === "string") {
							issues.push(" [regions/"+i+"] conBonus has type string when it must be object (format {\"1|2|3\":<conLevel>,\"1|2|3\":<conLevel>})");
						} else {
							if(Object.keys(c.conBonus).length > 2) {
								issues.push(" [regions/"+i+"] conBonus keys length is more than 2");
							}
						}
					}
					if(c.weeklyBoss === undefined) {
						issues.push(" [regions/"+i+"] weeklyBoss missing");
					} else if (itemDB[c.weeklyBoss] === undefined) {
						issues.push(" [regions/"+i+"] weeklyBoss invalid");
						if(c.weeklyBoss != "Unknown") {
							dp("\""+c.weeklyBoss+"\" does not exist (used by Traveler in regions)","items");
						}
					}
					if(c.include !== false && c.include !== undefined) {
						issues.push(" [regions/"+i+"] include invalid (must be false or undefined)");
						included = false;
					} else if (c.include === false) {
						issues.push(" [regions/"+i+"] include set to false (remove to allow usage)");
						included = false;
					}
				}
			}

			if(issues.length != 0) {
				dp(i+" has the following issues: "+issues,"characters",included);
			}
		}
		// Items
		for(let i in itemDB) {
			let c = itemDB[i];
			let issues = [];

			if(c.include !== undefined) {
				issues.push(" \"include\" should not be added to items");
			}
			if(c.rarity > 5 || c.rarity < 0) {
				issues.push(" rarity above 5 or below 0");
			}

			if(c.type === undefined) {
				issues.push(" type missing");
			} else if (itemTypes.indexOf(c.type) === -1) {
				issues.push(" type invalid");
			}

			if(c.type === "crown") {
				c.type = "other";
			}
			if(c.type !== undefined) {
				dimg(c.type+"/"+spaceToUnderscore(i)+".png","images");
			}
			if(issues.length != 0) {
				dp(i+" has the following issues:"+issues,"items");
			}
		}
		// Item groups
		for(let i in itemGroupDB) {
			let g = itemGroupDB[i];
			let issues = [];

			if(g.include !== undefined) {
				issues.push(" \"include\" should not be added to item groups");
			}
			if(g.priority === undefined) {
				issues.push(" priority missing");
			} else if (typeof(g.priority) !== "number") {
				issues.push(" priority is not a number");
			}

			if(g.craftUp !== undefined && g.craftUp !== false) {
				issues.push(" craftUp must be false or undefined");
			}

			if(g.canConvertTo !== undefined && g.canConvertTo !== false) {
				issues.push(" canConvertTo must be false or undefined");
			}
			if(g.convertType !== undefined && g.convertType !== "inter" && g.convertType !== "intra") {
				issues.push(" convertType must be undefined \"inter\" or \"intra\"");
			}
			if(g.convertType === "inter") {
				if(g.convertTo === undefined) {
					issues.push(" convertType set to \"inter\" while convertTo is unset");
				} else if(itemTypes.indexOf[g.convertTo] === -1) {
					issues.push(" convertType set to \"inter\" while convertTo is invalid");
				}
			} else if (g.convertType === "intra") {
				if(g.convertTo !== undefined) {
					issues.push(" convertType set to \"intra\" while convertTo is not undefined");
				}
			}
			if(g.items === undefined) {
				issues.push(" group items is missing");
			} else {
				for(let j in g.items) {
					let i = g.items[j];
					if(itemDB[i] === undefined) {
						issues.push(" item \""+i+"\" not found in itemDB");
					}
				}
			}
			
			if(issues.length != 0) {
				dp(i+" has the following issues:"+issues,"itemGroups");
			}
		}
		// Weapons
		for(let i in weapDB) {
			let c = weapDB[i];
			let issues = [];

			if(c.include !== false && c.include !== undefined) {
				issues.push(" include invalid (must be false or invalid)");
				dimg("weapon/"+spaceToUnderscore(i)+".png","imagesIncludeFalse");
			} else if (c.include === false) {
				issues.push(" include set to false (remove to allow usage)");
				dimg("weapon/"+spaceToUnderscore(i)+".png","imagesIncludeFalse");
			} else {
				if (c.icons !== undefined) {
					if(Array.isArray(c.icons)) {
						for(let j in c.icons) {
							dimg("weapon/"+spaceToUnderscore(i+"_"+c.icons[j])+".png","images");
						}
					} else {
						issues.push(" icons is not an array");
					}
				} else {
					dimg("weapon/"+spaceToUnderscore(i)+".png","images");
				}
			}

			if(c.rarity === undefined) {
				issues.push(" rarity missing");
			} else if(c.rarity > 5 || c.rarity < 0) {
				issues.push(" rarity above 5 or below 0");
			}

			if(c.type === undefined) {
				issues.push(" type missing");
			} else if (allWeaponTypes.indexOf(c.type) === -1) {
				issues.push(" type invalid");
			}
			if(c.weapon === undefined) {
				issues.push(" weapon ascension missing");
			} else if (itemGroupDB[c.weapon] === undefined) {
				issues.push(" weapon ascension invalid");
				if(c.weapon != "Unknown") {
					dp("\""+c.weapon+"\" does not exist (used by weapon "+i+")");
				}
			}

			if(c.common === undefined) {
				issues.push(" common missing");
			} else if (itemGroupDB[c.common] === undefined) {
				issues.push(" common invalid");
				if(c.common != "Unknown") {
					dp("\""+c.common+"\" does not exist (used by weapon "+i+")","items");
				}
			}

			if(c.elite === undefined) {
				issues.push(" elite missing");
			} else if (itemGroupDB[c.elite] === undefined) {
				issues.push(" elite invalid");
				if(c.elite != "Unknown") {
					dp("\""+c.elite+"\" does not exist (used by weapon "+i+")","items");
				}
			}

			if(issues.length != 0) {
				dp(i+" has the following issues:"+issues,"weapons");
			}
		}
		// Artifacts
		for(let i in artifactDB) {
			let c = artifactDB[i];
			let issues = [];
			var minNum = false, maxNum = false;

			if(c.include !== false && c.include !== undefined) {
				issues.push(" include invalid (must be false or invalid)");
				for(let j in c) {
					if(artifactTypes.indexOf(j) !== -1) {
						dimg("artifacts/"+j+"/"+spaceToUnderscore(removeQuotes(c[j]))+".png","imagesIncludeFalse");
					}
				}
			} else if (c.include === false) {
				issues.push(" include set to false (remove to allow usage)");
				for(let j in c) {
					if(artifactTypes.indexOf(j) !== -1) {
						dimg("artifacts/"+j+"/"+spaceToUnderscore(removeQuotes(c[j]))+".png","imagesIncludeFalse");
					}
				}
			} else {
				for(let j in c) {
					if(artifactTypes.indexOf(j) !== -1) {
						dimg("artifacts/"+j+"/"+spaceToUnderscore(removeQuotes(c[j]))+".png","images");
					}
				}
			}

			if(c.rarityMin === undefined) {
				issues.push(" rarityMin missing");
			} else if (typeof(c.rarityMin) != "number") {
				issues.push(" rarityMin is not a number");
			} else {
				minNum = true;
			}
			if(c.rarityMax === undefined) {
				issues.push(" rarityMax missing");
			} else if (typeof(c.rarityMax) != "number") {
				issues.push(" rarityMax is not a number");
			} else {
				maxNum = true;
			}
			if(maxNum && minNum) {
				if(c.rarityMax <= c.rarityMin) {
					issues.push(" rarityMax larger or same value as rarityMin");
				}
			}

			if(issues.length != 0) {
				dp(i+" has the following issues:"+issues,"artifacts");
			}
		}

		// other images
		for(let i = 1; i < 6; i++) {
			dimg("rarity/"+i+".png","images");
			dimg("rarity/mini-"+i+".png","images");
			dimg("icons/rarity/"+i+".png","images");
		}
		dimg("icons/elements/Physical.svg","images");
		for(let i in charTypes) {
			let t = charTypes[i];
			visions.push("Traveler_"+t);
			dimg("icons/elements/"+t+".svg","images");
			if(t === "Unaligned") {
				continue;
			}
			for(let j in charRegions) {
				let r = charRegions[j];
				if(r === null) {
					continue;
				}
				if(r === "Fontaine") {
					visions.push(r+"_"+t+"_Pneuma");
					visions.push(r+"_"+t+"_Ousia");
					continue;
				}
				visions.push(r+"_"+t);
			}
		}
		for(let i in visions) {
			let includeFalse = ["Traveler_Pyro","Traveler_Cryo", "Snezhnaya_Pyro", "Snezhnaya_Electro", "Snezhnaya_Cryo", "Snezhnaya_Dendro", "Snezhnaya_Anemo", "Snezhnaya_Geo"];
			let v = removeQuotes(visions[i]);
			if(includeFalse.indexOf(v) !== -1 || v.indexOf("Natlan") !== -1 || v.indexOf("Khaenriah") !== -1) {
				dimg("icons/visions/"+v+".png","imagesIncludeFalse");
			} else {
				dimg("icons/visions/"+v+".png","images");
			}
		}
		for(let i in allWeaponTypes) {
			dimg("icons/weapon/"+allWeaponTypes[i]+".png","images");
		}
		for(let i in artifactTypes) {
			let t = artifactTypes[i];
			dimg("artifacts/"+t+"/fallback.png","images");
		}
		let gemTypes = ["chunk","fragment","gemstone","sliver"];
		for(let i in gemTypes) {
			dimg("custom/convert_"+gemTypes[i]+".png","images");
		}
		for(let i in artiValidSubstats) {
			let k = artiValidSubstats[i].replace(/%/g,"_percent");
			dimg("icons/attributes/"+k+".svg","images",undefined,true);
		}
		dimg("icons/attributes/HB.svg","images",undefined,true);

		dimg("char/Unknown.png","images","Used for dropdowns");
		dimg("weapon/Unknown.png","images","Used for dropdowns");
		dimg("icons/addChar.svg","images","Used for party page");
		dimg("icons/info.svg","images","Used for sources");
		dimg("icons/itemFallback.png","images","Used for missing items");
	});
	function dp(text,placement,included=true) {
		let elem = Object.assign(document.createElement("div"), {textContent: text});
		if(!included) {
			elem.classList.add("includeFalse");
			elem.title = "\"include\" is set to false or undefined. Remove it to allow usage."
		}
		get(placement).appendChild(elem);
	}
	function dimg(src,placement,title=undefined,dropShadow=false) {
		let elem = Object.assign(document.createElement("img"));
		elem.height = 32;
		elem.width = 32;
		elem.src = "images/"+src;
		elem.title = title !== undefined ? title+" | images/"+src : "images/"+src;
		if(dropShadow) {
			elem.setAttribute("style","filter:drop-shadow(0 0 3px black)");
		}
		if(placement == "imagesIncludeFalse") {
			elem.setAttribute("onerror","dp(this.title+' has failed to load','imageErrorsIncludeFalse')");
		} else {
			elem.setAttribute("onerror","dp(this.title+' has failed to load','imageErrors')");
		}
		get(placement).appendChild(elem);
	}
	</script>
</html>