<!DOCTYPE html>
<html>
	<head>
		<title>Genshin Party Saver</title>
		<link rel="stylesheet" href="style.css">
		<script type="text/javascript" src="loadData.js"></script>

		<script type="text/javascript" src="scripts.js"></script>
		<script type="text/javascript" src="scripts/cookieLocalStorage.js"></script>
		<script type="text/javascript" src="scripts/prefs.js"></script>
		<script type="text/javascript" src="scripts/charWeapHandling.js"></script>
	</head>
	<!-- Hi, thanks for reading the HTML file. The JS at the bottom of the page is an absolute fucking mess. If you want to clean it up, feel free to fork this repo (linked in the page's footer tag) and make a pull request. -->
	<!--
	TODO:
	- MAKE SURE HIDE LIMITED IS WORKING AS INTENDED
	- ALLOW HIDING RARITY STARS
	- OPTIONAL VISIBILITY OF ARTIFACTS AND WEAPONS (visible by default right now, cannot hide)
	- UNASSIGNED WEAPON TO USE images/icons/weapon/<type>.png (done?)
	- ARTIFACTS SHOULD NOT BE STRINGS!!!
	- PARTY PROPERTIES INCLUDE:
		- CHARACTERS WITHIN PARTY HAVE THE FOLLOWING ADDITIONAL PROPERTIES:
			- (maybe) VISIBLE TO USER; THE LEVEL, ASC, SKILL, BURST AND CON OF THE CHARACTER.

	WHAT WILL NOT BE ADDED:
	- ANY SORT OF REFINEMENT/LEVEL OR HP/DEF/ATK/CRIT/HEALING BONUS/$TYPE DMG/ER/EM STATS. NONE OF THEM. SOURCE OF WEAPON/ARTIFACT IS LIKELY FINE THOUGH
	- NON-SOURCE RELATED WEAPON OR ARTIFACT DESCRIPTION. THESE WOULD TAKE UP TOO MUCH TIME AND BE UTTERLY POINTLESS. A LINK TO A GOOD WIKI MAYBE?
	-->
	<!-- 
	PARTY FORMAT TO BE CHANGED

	changeWeapon:
		- new format supported (mostly done?)
		- removing weapon shouldn't cock up
		- allow granular editing of weapon outside of (proposed) weapon page

	changeArtifact:
		- new format must be supported
		- removing artifact shouldn't cock up
		- allow granular editing of arti outside of (i doubt ill make it) artifact page

	addCharFromPopup:
		- new format must be supported (done with quick change)
		- allow chosing existing sets if any are found

	--
	
	FROM

	parties: [{id:$id,name:$name,?note:$note,chars:
		[{name:$char,?type:$travType,weapon:$weapon,artifacts:(as str)[{},{},{},{},{set:$set}]}]
	}]
	
	--
	TO

	parties: [{id:$id,name:$name,chars:
		[{name:$char,set:$id}]
	}]
	partiesVersion: "0.02"

	(saved within characters themselves (ie Ganyu.sets or Traveler.sets))
	sets: [
		{id:$id,weapon:$id,artifacts:[id:$id,null,null,null,null]}
	]
	
	weapons: weaponIDIndex contains name of weapon which contains a list of ids. localStorage contains weapon info in name of weapon

	artifacts:
		artifactIDIndex:
		{
			$set: { // set being "Adventurer" or similar
				"flower": [$id,$id,$id], (repeat 5 times per [flower,plume,etc], undefined/null for empty. No array for "Prayers..." sets.)
			}
		}
		localStorage to contain:
			(artifact) $set: [
				"flower": {[
					{
						id:$id,
						rarity:$rarity,
						exp:$exp,
						mainStat: $name, (skipped for flower and plume, must be valid in artiValidStats)
						mainStatValue: $value, (might be possible to calculate this based on mainStat, rarity and exp)
						substats:{$substat:$value,$substat:$value...} (each substat must be valid in artiValidSubstats and cannot match mainStat)
					}
				]}, (repeat per type of artifact -- for the prayers of _whatever_, they only have circlets and would instead use the below format)
			]
			"Prayers of" whatever: [
				{
					(same inner format as above. just no inner array)
				}
			]
	-->
	<!-- Exported party stuff for testing updating:
	{"parties":"[{\"id\":\"LgToSGH\",\"name\":\"\\\"the kids were stolen\\\"\",\"chars\":[{\"name\":\"Alhaitham\",\"weapon\":\"Dull Blade\",\"artifacts\":\"[{\\\"set\\\":\\\"Adventurer\\\"},{\\\"set\\\":\\\"Viridescent Venerer\\\"},{\\\"set\\\":\\\"Adventurer\\\"},{\\\"set\\\":\\\"Adventurer\\\"},{\\\"set\\\":\\\"Lucky Dog\\\"}]\"},{\"name\":\"Bennett\",\"weapon\":\"Dull Blade\",\"artifacts\":\"[{},{},{},{},{}]\"}]}]"}
	-->
	<!-- Second exported party for general testing:
		broken.
	-->
	<body class="hideLimited">
		<span><span style="font-size:xx-large;font-weight:bolder">Parties are currently borked and do not save.</span> Feel free to mess around on this page though. Please report any issues in the repo linked in the footer.</span>
		<div class="warning">
			<strong>A whole lot of things in localStorage have been reworked. You may need to reload. Your data should hopefully be fine.</strong>
		</div>

		<div>
			<a href="index.html">Home</a>
			<a href="inv.html">Inventory</a>
			<a href="characters.html">Characters</a>
		</div>

		<p style="font-family:monospace">css isn't anywhere close to done. most stuff "works" and there hopefully isn't anymore issues with this.
		<br>if you want to clear all your parties, paste the following command in the console:
		<br>localStorage.removeItem("parties")</p>

		<div class="vertFlex inputs">
			<span title="Limited-Timed items include Aloy and Flagship Event Weapons.">
				<label for="toggleLimited">Hide Limited-Timed Items</label>
				<input type="checkbox" class="defaultInput" key="prefs" pref="hideLimited" onchange="prefs.hideLimited = this.checked;updatePrefs();toggleLimitedItems()" id="toggleLimited" name="toggleLimited" checked>
			</span>
		</div>

		<div class="topFlex">
			<div class="notes">You can change Traveler's element, artifacts and held weapon by clicking on the respective icon. Ignoring names and notes, the same party restrictions that apply in-game also apply here.</div>
			<button class="newPartyButton" onclick="newParty(true)">Add New Party</button>
		</div>

		<div id="partyGroups"></div>

		<footer style="font-size:12px;overflow-x:auto;">
			Images are copyrighted by miHoYo / HoYoverse. Data was obtained using the Fandom site, the interactive map and from the game itself. This site <strong>does not</strong> use Cookies and is completely open source. You can view the repo <a href="https://github.com/LeafyLuigi/GenshinCalc">here</a>.
		</footer>
	</body>
	<script>
	'use strict';
	var parties = [], partyIndex = [], partiesCharsIndex = {};
	const partiesVersion = "0.02";
	pageType = "party";
	var hideWarning = () => {
		if(getLSItem("partiesVersion")==partiesVersion) get("warning","class")[0].style = "display:none";
	}
	window.addEventListener("load", () => {
		hideWarning();
		if(!prefs.hideLimited) document.getElementsByTagName("body")[0].classList.toggle("hideLimited");
		// check if preexisting parties are found and add them to html tree
		if(getLSItem("parties") != undefined && getLSItem("parties") != "[]") {
			// console.log(getLSItem("parties"))
			parties = parseLSItem("parties",[]);
			if(typeof(parties) == "string") {
				console.log("Parties needed another parse.")
				try {
					parties = JSON.parse(parties);
					setLSItem("parties",JSON.stringify(parties));
				}
				catch {
					console.error("Either localStorage is full or JSON.parse didn't work. Parties have been reset.");
					parties = [];
				}
			}

			if(getLSItem("partiesVersion") !== partiesVersion) parties = updateParties();

			if(JSON.stringify(parties) != "[]") {
				console.log(parties)
				partyIndex = parties.map(i => i.id);
				for (let i in partyIndex) {
					ids[partyIndex[i]] = "party";
					idIndex.push(partyIndex[i]);
					partiesCharsIndex[partyIndex[i]] = parties[partyIndex.indexOf(partyIndex[i])].chars.map(i => i.name);
				}
				// parties = JSON.parse(parties);
				for(let i in parties) {
					// console.log(parties[i])
					if(parties[i].name == undefined) parties[i].name=undefined;
					if(parties[i].notes == undefined) parties[i].notes=undefined;
					// console.log("before newParty()",parties[i].id,parties[i].chars,parties[i].name,parties[i].notes,parties[i]);
					newParty(false,parties[i].id,parties[i].chars,parties[i].name,parties[i].notes);
				}
			}
		} else {
			// newParty(true);
		}

		// test add new party OLD FORMAT
		// newParty(true,"asdfghj",`{"chars":[{"name":"Ganyu","weapon":"Dull Blade"},{"name":"Traveler","type":"Dendro","rarity":2,"weapon":"Song of Stillness"},{"name":"Shenhe","type":"Hydro","rarity":3}]}`)
		// newParty(true,"asdhaea",`{"chars":[{"name":"Ganyu","artifacts":[{"set":"Adventurer"},{"set":"Golden Troupe"},{},{},{}]}]}`)

		// dump all artifacts for testing
		// var html = "";
		// for (var i in artifactDB) {
		// 	for (var j in artifactTypes) {
		// 		console.log(i,j)
		// 		if(artifactDB[i][artifactTypes[j]] == undefined) continue;
		// 		html+="<img draggable=\"false\" height=\"16\" width=\"16\" src=\"images/artifacts/"+artifactTypes[j]+"/"+removeQuotes(spaceToUnderscore(artifactDB[i][artifactTypes[j]]))+".png\">";
		// 	}
		// }
		// get("artis").innerHTML = html;


		if(parties!=undefined) {
			partyIndex = parties.map(i => i.id);
			for(let i in partyIndex) {
				partiesCharsIndex[partyIndex[i]] = parties[partyIndex.indexOf(partyIndex[i])].chars.map(i => i.name);
			}
		}
	});

	var newParty = (saveParty=false,forcedID="",forcedChars=[],forcedName="",forcedNotes="") => {
		// forcedChars needs to be in the format of [{char:$char,?set:$setID}] (max length 4)
		var partyID = "", partyData = "";
		var partyCount = 0, partyCharsCount = 0;
		var contents = {};
		var isLSPartyDataEmpty = true;
		var partyName = "", partyNotes = "";

		console.info(saveParty,forcedID,forcedChars,forcedName,forcedNotes);

		// check if localStorage exists. If it does and saveParty is true, the new party will be added to it.
		if (getLSItem("parties") != null && getLSItem("parties") != "[]") {
			try {
				partyCount = Object.keys(JSON.parse(getLSItem("parties"))).length;
				isLSPartyDataEmpty = false;
				if(saveParty && JSON.stringify(JSON.parse(getLSItem("parties"))[partyCount - 1].chars) == "[]") {
					return;
				}
			}
			catch {
				console.error("Parties were corrupted. Below is the raw string.");
				console.log(getLSItem("parties"));
			}
		}

		// variable check stuff
		if(forcedNotes != undefined && forcedNotes != "") {
			partyNotes = forcedNotes;
		}
		if (JSON.stringify(forcedChars) != "[]") {
			contents.chars = forcedChars;
			partyCharsCount = contents.chars.length;
		}
		if (forcedID != "") {
			saveParty = false; // enforce saveParty=false
			partyID = forcedID;
		} else {
			partyID = createID("party");
		}
		if(forcedName != undefined && forcedName != "" && forcedName != '""') {
			try {partyName = JSON.parse(forcedName);}
			catch {partyName = forcedName;}
		} else {
			partyName = "Party "+partyID;
		}

		if(saveParty)partyData += "{\"id\":\"" + partyID + "\",";
		// party init
		var html = "<div class=\"party\" id=\""+partyID+"\">";
		// var el_partyContainer = Object.assign(document.createElement("div"), {id:partyID,classList:"party"});
		// console.log(el_partyContainer);

		// party meta; includes name, element combos and the delete button
		html += "<div class=\"partyMeta topFlex\">";
		
		// var el_partyMeta = Object.assign(document.createElement("div"), {classList:"partyMeta topFlex"});
		// // console.log(el_partyMeta);
		// // partyContainer.appendChild(partyMeta);
		// // name + combo group
		// var el_partyNameCombo = Object.assign(document.createElement("div"));
		// var el_partyNameContainer = Object.assign(document.createElement("div"));
		// // name
		// var el_partyNameLabel = Object.assign(document.createElement("label"), {for:partyID+"-name",textContent:"Party Name: "});
		// var el_partyName = Object.assign(document.createElement("input"), {classList:"partyName",type:"text",name:partyID+"-name",id:partyID+"-name",size:"25",maxlength:"50",value:partyName,placeholder:"Party Name"});
		// el_partyNameContainer.appendChild(el_partyNameLabel);
		// el_partyNameContainer.appendChild(el_partyName);

		// name + combo group
		html += "<div>";
		// name
		html += "<div>";
		html += "<label for=\""+partyID+"-name\">Party Name: </label>";
		html += "<input class=\"partyName\" type=\"text\" id=\""+partyID+"-name\" name=\""+partyID+"-name\" size=\"25\" maxlength=\"50\" value=\""+partyName+"\" placeholder=\"Party Name\" oninput=\"updatePartyName(&quot;"+partyID+"&quot;,this)\">";
		html += "</div>";

		if(saveParty) partyData+="\"name\":\"Party "+partyID+"\",";

		// // element combos if applicable
		// var el_partyCombos = Object.assign(document.createElement("div"), {classList:"partyCombos",id:partyID+"-combos"});
		// el_partyNameCombo.appendChild(el_partyNameContainer);
		// el_partyNameCombo.appendChild(el_partyCombos);
		// el_partyMeta.appendChild(el_partyNameCombo);

		// element combos if applicable - js would be needed for updating this.
		html += "<div class=\"partyCombos\" id=\""+partyID+"-combos\"></div>";
		// close name+combo group
		html += "</div>";
		
		// var el_partyDeleteButton = Object.assign(document.createElement("div"), {classList:"removeButton",id:partyID+"-remove"});
		// el_partyMeta.appendChild(el_partyDeleteButton);
		// el_partyContainer.appendChild(el_partyMeta);

		// delete button
		html += "<button id=\""+partyID+"-remove\" class=\"removeButton\" onclick=\"removeParty(&quot;"+partyID+"&quot;)\">Remove</button>";
		// close meta tag
		html += "</div>";

		// var el_partyChars = Object.assign(document.createElement("div"), {classList:"removeButton",id:partyID+"-party"});
		// party chars start
		html += "<div id=\""+partyID+"-party\" class=\"partyChars\">";

		if(saveParty)partyData += "\"chars\":[,"; // open character list
		for(var i = 0; i < partyCharsCount; i++) {
			// let el_partyChar = Object.assign(document.createElement("div"), {classList:"partyChar normal"});
			// let el_partyCharNameIconContainer = Object.assign(document.createElement("div"));

			var char = contents.chars[i].name;
			var setID = contents.chars[i].set; // this may turn up undefined. this is kinda normal and will be skipped.
			var rarity, type, artifacts, weapon, note = undefined;
			if(saveParty)partyData = partyData.splice(0,-1)+"{\"name\":\""+char+"\","; // open character
			// if(setID != undefined) {
			// 	let charSet = parseLSItem(char,{}).sets[setsIDIndex[char].indexOf(setID)];
			// 	artifacts = charSet.artifacts;
			// 	weapon = charSet.weapon;
			// 	// if(saveParty)partyData += "\"artifacts\":"+JSON.stringify(artifacts)+",";
			// 	// if(saveParty)partyData += "\"weapon\":\""+weapon+"\",";
			// } else {
			// 	artifacts = [null,null,null,null,null];
			// 	weapon = defaultWeapons[charDB[char].weapon];
			// }
			if(contents.chars[i].type == undefined) {
				if(char == "Traveler") {
					type = "Anemo";
				} else {
					type = charDB[char].type;
				}
			} else {
				type = contents.chars[i].type;
				if(char == "Traveler"&&saveParty) partyData += "\"type\": \""+type+"\",";
			}
			if(contents.chars[i].rarity == undefined) {
				rarity = charDB[char].rarity;
			} else {
				rarity = contents.chars[i].rarity;
				if(saveParty)partyData += "\"rarity\":\""+rarity+"\",";
			}
			if(contents.chars[i].note != undefined) {
				note = JSON.parse(contents.chars[i].note);
			}
			if(saveParty)partyData = partyData.slice(0,-1)+"},"; // close character

			// var charHTML = partyAddChar(partyID,char,type,rarity,weapon,artifacts,false,undefined,note);
			var charHTML = partyAddChar(partyID,char,type,rarity,setID,false,undefined,note);
			html += charHTML;
			// el_partyChar.innerHTML = charHTML;
		}
		if(saveParty)partyData = partyData.slice(0,-1)+"],"; // close character list

		// "add character" button that'll bring up a modal of sorts to add a character. any added characters should allow weapon + artifact editing and removal.
		html += "<div id=\""+partyID+"-addChar\" class=\"partyAddChar partyIntractable";
		if(partyCharsCount >= 4) {
			html = html.slice(0,html.indexOf("-combos")+9) + checkCombos(partyID) + html.slice(html.indexOf("-combos")+9)+" partyFull";
		}
		html += "\" onclick=\"partyAddCharStart(&quot;"+partyID+"&quot;,this)\"></div>";
		// close chars tag
		html += "</div>";

		// close outermost tag
		html+="</div>"
		console.log("partyData",partyData)
		if(saveParty){
			partyData = partyData.slice(0,-1)+"}"; // remove ending comma and close party
			// console.log(partyData,isLSPartyDataEmpty)
			console.log("attempted to save party data. parties:",parties,"partyData:",partyData)
			// if(!isLSPartyDataEmpty) {
			// 	setLSItem("parties",getLSItem("parties").slice(0,-1)+","+partyData+"]");
			// } else {
			// 	setLSItem("parties","["+partyData+"]");
			// 	// console.log(getLSItem("parties"))
			// }
			parties.push(JSON.parse(partyData));
			savePartyData();
		}
		get("partyGroups").innerHTML += html;

		// add partyContainer to partyGroups
		// get("partyGroups").appendChild(el_partyContainer);
		
		// // add events to items
		// get(partyID+"-name").addEventListener("input",function(){updatePartyName('"'+partyID+'"',this);});
		// get(partyID+"-remove").addEventListener("input",function(){removeParty('"'+partyID+'"')});

	};

	var clearPartyDoConfirm = "", wasPartyCleared = false;
	var removeParty = (partyID="") => {
		if(clearPartyDoConfirm == "") {
			get((partyID+"-remove")).innerText = "Confirm?";
			clearPartyDoConfirm = true;
			window.setTimeout(function(){if(!wasPartyCleared){console.info("Any errors relating to \"Uncaught TypeError: get(...) is null\" within the next few seconds can be safely ignored.");get((partyID+"-remove")).innerText = "Remove";clearPartyDoConfirm = partyID}},5000);
		} else {
			wasPartyCleared = true;
			clearPartyDoConfirm = "";
			parties.splice(partyIndex.indexOf(partyID),1);
			savePartyData();
			get(partyID).outerHTML = "";
			removeID(partyID);
			window.setTimeout(function(){wasPartyCleared = false},5000);
		}
	}

	var partyAddChar = (partyID="",char="Ganyu",type="Anemo",rarity="1",setID=null,addToTree=true,element=undefined,charNote=undefined) => {
		console.log(partyID,char,type,rarity,setID,addToTree,element,charNote)
		var forceReturnHTML = true;
		if(partyID == "") {
			console.warn("No Party ID was included. This may not work fully.");
		}
		if (addToTree && element == undefined) {
			console.warn("addToTree is true and the element this will be added to is undefined. This will return the html as a string instead. expect issues.");
			forceReturnHTML = true;
		} else if (addToTree) {
			forceReturnHTML = false;
		}
		var artifacts, weapon;
		if(setID != null && setID != "") {
			if(JSON.stringify(setsIDIndex) == "{}") { // basically just after data update

			}
			let charSet = parseLSItem(char,{}).sets[setsIDIndex[char].indexOf(setID)];
			artifacts = charSet.artifacts;
			console.log(artifacts)
			weapon = charSet.weapon != undefined ? getID(charSet.weapon,1) : defaultWeapons[charDB[char].weapon];
			console.log(weapon)
			// weapon = parseLSItem() // charSet.weapon;
		} else {
			artifacts = [null,null,null,null,null];
			weapon = defaultWeapons[charDB[char].weapon];
		}
		var html = "";
		// start character
		// let el_char = Object.assign(document.createElement("div"), {classList:"partyChar normal"});
		html += "<div class=\"partyChar normal\">";

		html += makeCharIcon(char,type,rarity,partyID);

		// add optional weapon+artifact stuff
		html += "<div class=\"partyOptional\">";

		// notes are useful
		html += "<input class=\"partyCharNote\" type=\"text\" size=\"25\" maxlength=\"50\" placeholder=\"Add note...\" pattern=\"[^\\`]\" oninput=\"updateCharNotes(&quot;"+partyID+"&quot;,&quot;"+char+"&quot;,this)\"";
		if(charNote != undefined) html += " value=\""+charNote+"\"";
		html += ">";

		// group weapons and artis
		html += "<div class=\"partyWeaponArtiGroup\">";
		// this should probably be a dropdown
		html += "<div class=\"partyWeapon\">";

		html += "<img draggable=\"false\" class=\"partyWeaponImg partyIntractable\" loading=\"lazy\" height=\"32\" width=\"32\" src=\"images/weapon/"+spaceToUnderscore(weapon)+".png\" onclick=\"changeWeaponStart(this)\">";

		html += "</div>";

		// start artifacts group
		html += "<div class=\"partyArtifacts\">";
		if(typeof(artifacts) == "string") {
			try {
				artifacts = JSON.parse(artifacts);
			} catch {
				console.error("The artifacts belonging to "+char+" from party "+partyID+" appear to be corrupted. Here's what they were:",artifacts);
				artifacts = [null,null,null,null,null];
			}
		}
		for (var j = 0; j < artifacts.length; j++) {
			if(artifacts[j])
			var artifact = artifacts[j];
			var artifactIcon = undefined;
			html += "<div class=\"partyArtifact\">";
			// THIS PART NEEDS REWRITE FOR NEW FORMAT
			if(artifact != null) {
				var artifactSet = ids[artifact].split("--")[1];
				artifactIcon = artifactDB[artifactSet][artifactTypes[j]];
			} else {
				artifactIcon = "fallback";
			}
			//
			html += "<img draggable=\"false\" class=\"partyArtifactImage partyIntractable\" loading=\"lazy\" height=\"32\" width=\"32\" src=\"images/artifacts/"+artifactTypes[j]+"/"+spaceToUnderscore(removeQuotes(artifactIcon))+".png\" onclick=\"changeArtifactStart(this)\">";
			html += "</div>";
		}
		// close artifact group
		html += "</div>";
		// close partyWeaponArtiGroup
		html += "</div>";

		// close optional weapon+artifact stuff
		html += "</div>";
		// add buttons to move or remove character here
		html += "<div class=\"partyCharControls\">";
		// move left, remove and move right button
		html += "<button class=\"partyMoveCharButton\" onclick=\"moveCharLeft(getCharElement(this));\">&lt;</button>";
		html += "<button class=\"partyRemoveCharButton\" onclick=\"removeChar(getCharElement(this));\">Remove</button>";
		html += "<button class=\"partyMoveCharButton\" onclick=\"moveCharRight(getCharElement(this));\">&gt;</button>";
		// close buttons
		html += "</div>";
		// close character
		html += "</div>";
		if(!forceReturnHTML) {
			element.classList.add("noEvents");
			element.insertAdjacentHTML("beforebegin",html);
			window.setTimeout(function(){element.innerText = ""; element.classList.remove("noEvents")},0);
		} else {
			return html;
		}
	}
	// make a character icon in a similar way to item icons
	var makeCharIcon = (char="Ganyu",type="Anemo",rarity="1",partyID="",returnHTML=true) => {
		if(returnHTML) {
			var html = "";
			html += "<div>";
			html += "<div class=\"partyCharName\">"+char+"</div>";
			// get char type icon, image, rarity and throw them into a nice box
			html += "<div class=\"partyCharIcon rarity-"+rarity+"\">";
			html += "<img draggable=\"false\" loading=\"lazy\" class=\"partyCharImage\" src=\"images/char/"+spaceToUnderscore(char)+".png\">";

			// type
			html += "<img draggable=\"false\" loading=\"lazy\" class=\"partyCharType";
			if(char == "Traveler" && partyID != "") html += " partyTravType partyIntractable\" id=\""+partyID+"-travType\" onclick=\"changeTravTypeStart(this);";
			html += "\" height=\"32\" width=\"32\" src=\"images/icons/elements/"+type+".svg\">";

			html += "<img draggable=\"false\" loading=\"lazy\" class=\"rarityIcon extraIcon\" src=\"images/icons/rarity/"+rarity+".png\">";
			// close icon group
			html += "</div>";
			html += "</div>";
			return html;
		} else {
			var el_charNameIconContainer = Object.assign(document.createElement("div"));
			var el_charName = Object.assign(document.createElement("div"), {classList:"partyCharName",textContent:char});
			var el_charIconContainer = Object.assign(document.createElement("div"), {classList:"partyCharIcon rarity"+rarity});
			var el_charImage = Object.assign(document.createElement("img"), {classList:"partyCharImage",draggable:false,loading:"lazy",src:"images/char/"+spaceToUnderscore(char)+".png"});
			var el_charType = Object.assign(document.createElement("img"), {classList:"partyCharType",height:32,width:32,draggable:false,loading:"lazy",src:"images/icons/elements/"+type+".svg"});
			var el_charRarityIcon = Object.assign(document.createElement("img"), {classList:"rarityIcon extraIcon",draggable:false,loading:"lazy",src:"images/icons/rarity/"+rarity+".png"});
			el_charIconContainer.appendChild(el_charImage);
			el_charIconContainer.appendChild(el_charType);
			el_charIconContainer.appendChild(el_charRarityIcon);
			el_charNameIconContainer.appendChild(el_charName);
			el_charNameIconContainer.appendChild(el_charIconContainer);
			console.log("need to check for trav and add event to el_charType");
			return el_charNameIconContainer;
		}
	}

	var checkCombos = (partyID) => {
		/*
			Hi important notes:

			All code within this comment block is psudo-code and not representative of actual game code.
			Unaligned Traveler does not activate Protective Canopy (4 unique types in party) for some reason.
			Unaligned Traveler **MIGHT** work with Nilou's bloom despite only specifying Hydro and Dendro

			This may mean that the Unaligned "element" is the the same as an empty slot; a Null or Undefined.
			Protective Canopy isn't activated when PartySize == 4 but ElementsInPartyExceptUnaligned == 4
			Nilou's bloom is actiavted when PartySize == 4 AND ElementsInPartyExceptUnaligned == "Hydro" and "Dendro"

			I do not desire to mod the game to check but other elemental resonances may work with a full party.

			These notes may be updated at a later date with more correct info.
		*/
		var partyTypes = [];
		var partyChars = parties[partyIndex.indexOf(partyID)].chars;
		var html = "";
		for (let i in partyChars) {
			if (partyChars[i].type != undefined) {
				partyTypes.push(partyChars[i].type)
			} else if(partyChars[i].name != "Traveler") {
				partyTypes.push(charDB[partyChars[i].name].type);
			} else {
				console.warn("Traveler should ALWAYS have an associated type when in a party. An unaligned type will be used instead and Traveler's type will be reset to Anemo.");
				partyTypes.push("Unaligned");
				parties[partyIndex.indexOf(partyID)].chars[i].type = "Anemo";
			}
		}

		// Code below from https://stackoverflow.com/questions/19395257/
		const counts = {};
		partyTypes.forEach(function (i) { counts[i] = (counts[i] || 0) + 1; });
		// console.log(counts)

		// console.log(Object.keys(counts).indexOf("Unaligned"));
		// IF IT SO HAPPENS THAT IF ANY PARTY MEMBER IS UNALIGNED AND NO RESONANCES HAPPEN, THIS ENTIRE SECTION WILL BE SKIPPED.
		if(Object.keys(counts).length == 4 && Object.keys(counts).indexOf("Unaligned") == -1) {
			html += "<span>Elemental Resonance: ";
			for(let i in partyTypes) {html += "<div class=\"partyComboIcon elementType"+partyTypes[i]+"\"><img draggable=\"false\" height=\"24\" width=\"24\" loading=\"lazy\" src=\"images/icons/elements/"+partyTypes[i]+".svg\"></div>"}
			html += " Protective Canopy</span>"
		} else {
			var potentialHtml = "<span>Elemental Resonance(s): ";
			var resonances = [];
			var elementsDone = {};
			for(let i in partyTypes) {
				elementsDone[partyTypes[i]] = (elementsDone[partyTypes[i]] || 0) + 1;
				if(counts[Object.keys(counts)[i]] > 1) {resonances.push(Object.keys(counts)[i]);}
				if(counts[partyTypes[i]] > 1 && elementsDone[partyTypes[i]] < 3) potentialHtml += "<div class=\"partyComboIcon elementType"+partyTypes[i]+"\"><img draggable=\"false\" height=\"24\" width=\"24\" loading=\"lazy\" src=\"images/icons/elements/"+partyTypes[i]+".svg\"></div>";
			}
			for (let i in resonances) {
				if(resonances[i] == "Pyro") {potentialHtml+="Fervent Flames"}
				else if(resonances[i] == "Hydro") {potentialHtml+="Soothing Water"}
				else if(resonances[i] == "Electro") {potentialHtml+="High Voltage"}
				else if(resonances[i] == "Cryo") {potentialHtml+="Shattering Ice"}
				else if(resonances[i] == "Anemo") {potentialHtml+="Impetuous Winds"}
				else if(resonances[i] == "Geo") {potentialHtml+="Enduring Rock"}
				else if(resonances[i] == "Dendro") {potentialHtml+="Sprawling Greenery"}
				potentialHtml += " and ";
			}
			potentialHtml = potentialHtml.slice(0, -5)+"</span>";
			if (resonances.length == 0) {
				html = "";
			} else if(resonances.length == 1) {
				html = potentialHtml.replace("(s)","")
			} else {
				html = potentialHtml.replace("(s)","s")
			}
		}
		try {get(partyID+"-combos").innerHTML = html;}
		catch {return html}
	}

	var addCharFromPopup = (element) => {
		var char = element.childNodes[0].innerText;
		var partyID = getPartyID(element);
		partyAddChar(getPartyID(element),char,charDB[char].type,charDB[char].rarity,null,true,get(partyID+'-addChar'));
		parties[partyIndex.indexOf(partyID)].chars.push({name:char});
		savePartyData();
		get(partyID+"-addChar").classList.remove("open");
		if(parties[partyIndex.indexOf(partyID)].chars.length > 3) {
			get(partyID+"-addChar").classList.add("partyFull");
			checkCombos(partyID);
		}
		window.setTimeout(function(){get(partyID+"-addChar").setAttribute("onclick","partyAddCharStart(\""+partyID+"\",this)")}, 0);
		get(partyID).removeAttribute("popupdisabled");
	}

	var removePopup = (element,kind) => {
		var partyID = getPartyID(element);
		get(partyID).removeAttribute("popupdisabled");
		if(kind == "addChar") {
			get(partyID+"-addChar").innerHTML = "";
			get(partyID+"-addChar").classList.remove("open");
			window.setTimeout(function(){get(partyID+"-addChar").setAttribute("onclick","partyAddCharStart(\""+partyID+"\",this)")}, 0);
		} else if (kind == "trav") {
			getCharElement(get(partyID+"-travType")).childNodes[[getCharElement(get(partyID+"-travType")).childElementCount - 1]].outerHTML = "";
			window.setTimeout(function(){get(partyID+"-travType").setAttribute("onclick","changeTravTypeStart(this);")}, 0);
		} else if (kind == "weapon") {
			getCharElement(element).childNodes[1].childNodes[1].childNodes[0].childNodes[0].setAttribute("onclick", "changeWeaponStart(this);");
			getCharElement(element).childNodes[[getCharElement(element).childElementCount - 1]].outerHTML = "";
		} else if (kind == "artifact") {
			getPopupElement(element).previousElementSibling.setAttribute("onclick","changeArtifactStart(this)");
			getPopupElement(element).outerHTML = "";
		}
	}
	var makePopup = (data,title="",search=false,noTitle=false) => {
		// popup base.
		// data is an array of what'll be within the popup. each point in the data MUST be strings.
		// title is an optional string for a title, it's also used to determine what kind of data is being used.
		// search and noTitle are bools for if a search bar should be present or if the title shouldn't be added to html
		if(data === undefined) {
			throw new Error("Do not call makePopup with undefined data.");
		}
		var html = "<div class=\"partyPopup\">";
		if(title != "" && !noTitle) html += "<div class=\"partyPopupHeader\"><div class=\"partyPopupTitle\">"+title+"</div>";
		html += "<div class=\"partyPopupClose\" onclick=\"removePopup(this,";
		if(title.toLowerCase().indexOf("character") != -1) {
			html += "&quot;addChar&quot;";
		} else if (title.toLowerCase().indexOf("weapon") != -1) {
			html += "'weapon'";
		} else if (title.toLowerCase().indexOf("artifact") != -1) {
			html += "'artifact'";
		} else if (title.toLowerCase().indexOf("traveler") != -1) {
			html += "'trav'";
		} 
		html += ")\">X</div></div>";
		// if(search) {} // add search bar

		html += "<div class=\"partyPopupContent";

		if(title.toLowerCase().indexOf("character") != -1) {
			html += " mini\">";
			for (var i in data) {
				if(charDB[data[i]].include == false) continue;
				var charString = makeCharIcon(data[i],charDB[data[i]].type,charDB[data[i]].rarity);
				charString = charString.replace("<div>","<div "+(data[i] == "Aloy"?"class=\"limited\" ":"")+"onclick=\"addCharFromPopup(this)\">");
				html += charString;	
			}
		} else if (title.toLowerCase().indexOf("weapon") != -1) {
			html += " weaponSelection\">";
			for (var i in data) {
				if(allWeaponTypes.indexOf(data[i]) != -1) {
					html+="<div onclick=\"changeWeapon(this,&quot;remove&quot;)\" class=\"partyIntractable partyPopupWeapon\">";
					html+="<img draggable=\"false\" loading=\"lazy\" height=\"32\" width=\"32\" src=\"images/icons/weapon/"+data[i]+".png\">";
					html+="<span>Remove</span></div>";
					continue;
				}
				html += "<div onclick=\"changeWeapon(this,&quot;"+data[i]+"&quot;)\" class=\"partyIntractable partyPopupWeapon rarity-"+weapDB[data[i]].rarity;
				if(weapDB[data[i]].source == "event") html += " limited";
				html += "\">";
				if(weapDB[data[i]].icons !== undefined && Array.isArray(weapDB[data[i]].icons)) {
					for(var j in weapDB[data[i]].icons) {
						html += makeImg("images/weapon/"+spaceToUnderscore(data[i]+"_"+weapDB[data[i]].icons[j])+".png",32,32,["dropdownWeaponImg"]);
					}
				} else {
					html += makeImg("images/weapon/"+spaceToUnderscore(data[i])+".png",32,32,["dropdownWeaponImg"]);
				}
				html+="<span>";
				if(weapDB[data[i]].title != undefined) {html += weapDB[data[i]].title} else {html += data[i]}
				html += "</span></div>";
			}
		} else if (title.toLowerCase().indexOf("artifact") != -1) {
			html += " artifactSelection\">";
			var artifactType = data.shift();
			for (let i in data) {
				var artifactIcon = "fallback";
				if(data[i] != "fallback") {artifactIcon = spaceToUnderscore(removeQuotes(artifactDB[data[i]][artifactType]))}
				html += "<div class=\"partyPopupArtifact partyIntractable\" onclick=\"changeArtifact(this,&quot;"+artifactType+"&quot;,&quot;"+data[i]+"&quot;)\"><img draggable=\"false\" loading=\"lazy\" src=\"images/artifacts/"+artifactType+"/"+artifactIcon+".png\" height=\"32\" width=\"32\"><span>";
				if(data[i] != "fallback") {html += artifactDB[data[i]][artifactType]} else {html += "Remove"}
				html += "</span></div>";
			}
		} else if (title.toLowerCase().indexOf("traveler") != -1) {
			html += "\">";
			for (var i in data) {
				html += "<div onclick=\"changeTravType(this,'"+data[i]+"')\" class=\"partyIntractable partyPopupTravelerType";
				if(data[i] == "Unaligned") html += " limited";
				html += "\"><img draggable=\"false\" width=\"48\" height=\"48\" src=\"images/icons/elements/"+data[i]+".svg\"><span>"+data[i]+"</span></div>";
			}
		} else {
			console.error("missing title. we gon abort.");
			html += "\">";
		}

		html += "</div>";

		html += "</div>";
		// console.log(html)
		return html;
	}
	var getPopupElement = (element) => {
		do {element = element.parentNode} while (element.classList.contains("partyPopup") == false); return element;
	}

	var savePartyData = () => {
		// ran fairly often to save the party data.
		partyIndex = parties.map(i => i.id);
		for(var i in partyIndex) {
			partiesCharsIndex[partyIndex[i]] = parties[partyIndex.indexOf(partyIndex[i])].chars.map(i => i.name);
		}
		console.log("attempted to save party data. parties:",parties)
		console.trace(parties);

		// if(JSON.stringify(parties) == "[]") {
		// 	clearLSItem("parties");
		// } else {
		// 	if (Array.isArray(parties)) {
		// 		setLSItem("parties", JSON.stringify(parties));
		// 	} else {
		// 		setLSItem("parties", "["+JSON.stringify(parties)+"]");
		// 	}
		// }
	}

	var updatePartyName = (partyID, element) => {
		var newName = parseHTMLSafe(val(element,true).trim());
		if(newName != "") {
			parties[partyIndex.indexOf(partyID)].name = JSON.stringify(newName);
			savePartyData();
		}
	}
	var updateCharNotes = (partyID, charName, element) => {
		var newNote = parseHTMLSafe(element.value.trim());
		if(newNote != "") {
			parties[partyIndex.indexOf(partyID)].chars[partiesCharsIndex[partyID].indexOf(charName)].note = JSON.stringify(newNote);
			savePartyData();
		} else {
			delete parties[partyIndex.indexOf(partyID)].chars[partiesCharsIndex[partyID].indexOf(charName)].note;
			savePartyData();
		}
	}

	// popup to add character
	var partyAddCharStart = (partyID,element) => {
		// have popup with a list of characters appear if character count is less than 4
		// selectable characters will follow these rules:
		// - no duplicate characters
		// - seriously that should be it
		// this popup will disappear upon character selection
		// element should be the $partyID-addChar element.
		if (get(partyID).getAttribute("popupdisabled") != null) {
			throw new Error("One popup per party please thank you~ this should really close instead.");
		}
		get(partyID+"-addChar").classList.add("open");
		get(partyID+"-addChar").removeAttribute("onclick");
		var allowedChars = [];
		for(let i in charDB) {allowedChars.push(i)}
		element.parentNode.attributes.onclick = "";
		var partyChars = parties[partyIndex.indexOf(partyID)].chars;
		if(partyChars.length > 4) {
			throw new Error("You cannot add more than 4 characters to a party.");
		}

		// reduce valid characters down from all possible to not-in-party
		for (var i in partyChars) {
			allowedChars.splice(allowedChars.indexOf(partyChars[i].name),1);
		}

		// search bar wanted, might reuse code from index.html
		var html;
		html = makePopup(allowedChars,"Add a Character",false);
		element.insertAdjacentHTML("beforeend",html);
		get(partyID).setAttribute("popupdisabled","");
	}

	// change traveler type
	var changeTravType = (element,type) => {
		var char = getCharElement(element).firstChild.firstChild.innerText;
		var partyID = getPartyID(element);
		get(partyID+"-travType").setAttribute("src","images/icons/elements/"+type+".svg");
		parties[partyIndex.indexOf(partyID)].chars[partiesCharsIndex[partyID].indexOf(char)].type = type;
		if(partiesCharsIndex[partyID].length == 4) checkCombos(partyID);
		removePopup(element,"trav");
		savePartyData();
	}
	var changeTravTypeStart = (element) => {
		// have popup with (current) types as well as unaligned (likely hidden without show event only or something)
		// only changes the source image. seriously, that's it.
		if (get(getPartyID(element)).getAttribute("popupdisabled") != null) {
			throw new Error("One popup per party please thank you~ this should really close instead.");
		}
		element.removeAttribute("onclick");
		var currentElement = element.getAttribute("src").substr(22).slice(0, -4);
		var allValidTravTypes = [];
		for (var i in travTypeOrder) {
			if(travTypeOrder[i] != currentElement) {
				allValidTravTypes.push(travTypeOrder[i]);
			}
		}
		getCharElement(element).insertAdjacentHTML("beforeend",makePopup(allValidTravTypes,"Change Traveler's element"));
		get(getPartyID(element)).setAttribute("popupdisabled","");
	}

	// change weapon
	var changeWeapon = (element,newWeapon) => {
		// first it gets the character's name from the image then gets a list of valid weapons to choose from. also swaps alt text
		var charName = getCharElement(element).firstChild.firstChild.innerText;
		var partyID = getPartyID(element);
		var party = getID(partyID);
		var partyChar = party.chars[partiesCharsIndex[partyID].indexOf(charName)];
		var wasSetUnknown = false;
		// console.log(partyChar)

		// check if allWeaponTypes.indexOf(newWeapon) != -1 for removal

		var set = {};
		var setID;
		if(partyChar.set == undefined) {
			// creating a new set
			setID = createID("set--"+charName);
			set.id = setID;
			wasSetUnknown = true;
		} else {
			set = getID(partyChar.set);
		}
		console.log(set);

		// assumption is not removing the weapon
		if(set.weapon == undefined) {
			var weapID = createID("weap--"+newWeapon);
			var weapObj = {id:weapID,usedIn:{}}
			set.weapon = weapID;
			weapObj.usedIn[charName] = [set.id];
			if(weaponIDIndex[newWeapon] == undefined) weaponIDIndex[newWeapon] = [];
			weaponIDIndex[newWeapon].push(weapID);
			if(weaponInfoIndex[newWeapon] == undefined) weaponInfoIndex[newWeapon] = [];
			weaponInfoIndex[newWeapon].push(weapObj);
			// setLSItem(newWeapon,JSON.stringify(weaponInfoIndex[newWeapon]));
		} else {
			// a check needs to be in place for checking if the only thing in the set is the weapon.
			var oldWeap = getID(set.weapon);
			console.log(oldWeap);

			// line appears to nuke the set regardless. this'll want fixing.
			// oldWeap.usedIn[charName].splice([setsIDIndex[charName].indexOf(set.id)],1);

			if(oldWeap.usedIn[charName].length == 0) delete oldWeap.usedIn[charName];
			if(JSON.stringify(oldWeap.usedIn) == "{}") delete oldWeap.usedIn;
			if(JSON.stringify(oldWeap) == "{\"id\":\""+oldWeap.id+"\"}") {
				// TODO: delete weapon info entirely if this part is triggered
				console.log("IT'S NULL");
			}
			// lines appear to nuke the set regardless. this'll want fixing.
			// setsIDIndex[charName].splice(setsIDIndex[charName].indexOf(set.id),1);
			// if(setsIDIndex[charName].length == 0) delete setsIDIndex[charName];
		}

		// add new set to character
		if(wasSetUnknown && newWeapon != "remove") {
			if(charInfoIndex[charName] == undefined) charInfoIndex[charName] = {};
			if(charInfoIndex[charName].sets == undefined) charInfoIndex[charName].sets = [];
			charInfoIndex[charName].sets.push(set);
			if(setsIDIndex[charName] == undefined) setsIDIndex[charName] = [];
			setsIDIndex[charName].push(setID);
			partyChar.set = setID;
		}

		let iconElem = getCharElement(element).childNodes[1].childNodes[1].childNodes[0].childNodes[0];
		if(newWeapon == "remove") {
			iconElem.setAttribute("src","images/icons/weapon/"+charDB[charName].weapon+".png");
		} else {
			iconElem.setAttribute("src","images/weapon/"+spaceToUnderscore(newWeapon)+".png");
		}
		// if(charInfoIndex[char] == undefined) charInfoIndex[char] = {};
		// if(setsIDIndex[char] == undefined) {
		// 	// no set? we're making one!
		// 	charInfoIndex[char].sets.push
		// }
		// parties[partyIndex.indexOf(partyID)].chars[partiesCharsIndex[partyID].indexOf(char)].weapon = newWeapon;
		// setLSItem(charName,JSON.stringify(charInfoIndex[charName]));
		removePopup(element,"weapon");
		savePartyData();
	}
	var changeWeaponStart = (element) => {
		// first it gets the character's name from the image then gets a list of valid weapons to choose from. also swaps alt text
		if (get(getPartyID(element)).getAttribute("popupdisabled") != null) {
			throw new Error("One popup per party please thank you~ this should really close instead.");
		}
		element.removeAttribute("onclick");
		var char = getCharElement(element).firstChild.firstChild.innerText;
		var currentWeapon = underscoreToSpace(element.getAttribute("src").substr(14).slice(0,-4));
		var allowedWeapons = [];
		
		// TODO: add check for adding "fallback"
		allowedWeapons.push(charDB[char].weapon);

		if(allWeaponTypes.indexOf(currentWeapon) != -1) allowedWeapons.push(currentWeapon);
		for (var i in allWeapons[allWeaponTypes.indexOf(charDB[char].weapon)]) {
			if(allWeapons[allWeaponTypes.indexOf(charDB[char].weapon)][i] != currentWeapon) {allowedWeapons.push(allWeapons[allWeaponTypes.indexOf(charDB[char].weapon)][i])}
		}
		if(char.substr(-1,1) == "s") {char += "'"} else {char += "'s"}
		var html = makePopup(allowedWeapons,"Change "+char+" weapon");
		getCharElement(element).insertAdjacentHTML("beforeend",html);
		get(getPartyID(element)).setAttribute("popupdisabled","");
	}

	// change artifact
	var changeArtifact = (element,artifactType,newArtifact,artifactID=null) => {
		// swap out an artifact for another
		var char = getCharElement(element).firstChild.firstChild.innerText;
		var partyID = getPartyID(element);
		var partyChar = parties[partyIndex.indexOf(partyID)].chars[partiesCharsIndex[partyID].indexOf(char)];
		var charArtifacts;
		var setID, wasSetUnknown = false, artiSetHasOneType = false;
		var artifactIcon = "fallback";

		// create artifact id just in case -- needs check for existing artifacts
		if(artifactID === null) {
			// console.log(allArtifactGroupsWithOneType,newArtifact, allArtifactGroupsWithOneType.indexOf(newArtifact))
			if(allArtifactGroupsWithOneType.indexOf(newArtifact) == -1) {
				artifactID = createID("arti--"+newArtifact+"--"+artifactType,7,artifactID);
			} else {
				artiSetHasOneType = true;
				artifactID = createID("arti--"+newArtifact,7,artifactID);
			}
		}

		// console.log("artiType",artifactType,"newArti",newArtifact)

		// get set id for updating
		var set = {};
		if(partyChar.set !== undefined) {
			setID = partyChar.set;
			set = charInfoIndex[char].sets[setsIDIndex[char].indexOf(setID)];
		} else {
			setID = createID("set--"+char);
			set.id = setID;
			wasSetUnknown = true;
		}

		if(newArtifact != "fallback") {
			artifactIcon = spaceToUnderscore(removeQuotes(artifactDB[newArtifact][artifactType]));
		}
		if(partyChar.artifacts !== undefined) {
			// more legacy stuff. it shouldn't be placed there anymore.
			try {
				charArtifacts = JSON.parse(partyChar.artifacts);
			}
			catch {
				console.error("Couldn't parse JSON when changing artifact. Below is what it was. This will reset the character's artifacts.");
				console.log(partyChar.artifacts);
				charArtifacts = [null,null,null,null,null];
			}
		} else if(set.artifacts !== undefined) {
			charArtifacts = set.artifacts;
		} else {
			charArtifacts = [null,null,null,null,null];
		}

		if(artifactIcon != "fallback") {
			charArtifacts[artifactTypes.indexOf(artifactType)] = artifactID;
			var artiObj = {id:artifactID,usedIn:{}}
			artiObj.usedIn[char] = [set.id];
			if(artiSetHasOneType) {
				if (artifactIDIndex[newArtifact] == undefined) artifactIDIndex[newArtifact] = [];
				artifactIDIndex[newArtifact].push(artiObj);
				if (artifactInfoIndex[newArtifact] == undefined) artifactInfoIndex[newArtifact] = [];
				artifactInfoIndex[newArtifact].push(artiObj);
			} else {
				if (artifactIDIndex[newArtifact] == undefined) artifactIDIndex[newArtifact] = {};
				if (artifactIDIndex[newArtifact][artifactType] == undefined) artifactIDIndex[newArtifact][artifactType] = [];
				artifactIDIndex[newArtifact][artifactType].push(artiObj);
				if (artifactInfoIndex[newArtifact] == undefined) artifactInfoIndex[newArtifact] = {};
				if (artifactInfoIndex[newArtifact][artifactType] == undefined) artifactInfoIndex[newArtifact][artifactType] = [];
				artifactInfoIndex[newArtifact][artifactType].push(artiObj);
			}
			// setLSItem(newArtifact,JSON.stringify(artifactInfoIndex[newArtifact]));
		} else {
			charArtifacts[artifactTypes.indexOf(artifactType)] = null;
		}
		// console.log(charArtifacts,artifactTypes,artifactType,artifactID)

		set.artifacts = charArtifacts;

		// add new set to character
		if (wasSetUnknown && newArtifact != "remove") {
			if (charInfoIndex[char] == undefined) charInfoIndex[char] = {};
			if (charInfoIndex[char].sets == undefined) charInfoIndex[char].sets = [];
			charInfoIndex[char].sets.push(set);
			if (setsIDIndex[char] == undefined) setsIDIndex[char] = [];
			setsIDIndex[char].push(setID);
			partyChar.set = setID;
		}

		getPopupElement(element).previousElementSibling.setAttribute("src","images/artifacts/"+artifactType+"/"+artifactIcon+".png");
		// setLSItem(char, JSON.stringify(charInfoIndex[char]));
		removePopup(element, "artifact");
		savePartyData();
	}
	var changeArtifactStart = (element) => {
		// swap out an artifact image for another
		if (get(getPartyID(element)).getAttribute("popupdisabled") != null) {
			throw new Error("One popup per party please thank you~ this should really close instead.");
		}
		element.removeAttribute("onclick");
		var allowedArtifacts = [];
		var artifactType = element.getAttribute("src").slice(17).slice(0,element.getAttribute("src").slice(17).indexOf("/"));
		var artifactName = underscoreToSpace(element.getAttribute("src").slice(18+artifactType.length).slice(0,-4));

		if(artifactName == "fallback") {
			allowedArtifacts.push(artifactType);
			for(var i in allArtifactGroups) {
				if(artifactDB[allArtifactGroups[i]][artifactType] != undefined) {allowedArtifacts.push(allArtifactGroups[i])}
			}
		} else {
			allowedArtifacts.push(artifactType,"fallback");
			for(var i in allArtifactGroups) {
				if(artifactDB[allArtifactGroups[i]][artifactType] != undefined && removeQuotes(artifactDB[allArtifactGroups[i]][artifactType]) != artifactName) allowedArtifacts.push(allArtifactGroups[i]);
			}
		}
		// console.log(allowedArtifacts)
		var html = makePopup(allowedArtifacts,"Change the artifact to what?");
		element.insertAdjacentHTML("afterend",html);
		get(getPartyID(element)).setAttribute("popupdisabled","");
	}

	// get char html element
	var getCharElement = (element) => {
		do {element = element.parentNode} while (!element.classList.contains("partyChar")); return element;
	}
	var getPartyID = (element) => {
		while (element.id == "" && (element.tagName != "HTML"||element.tagName == undefined)) {element = element.parentNode}
		if(element.id != "") {
			if(element.id.length == 7) {
				return element.id;
			} else {
				// console.warn("The found ID may not be correct.")
				return element.id.slice(0,7);
			}
		} else {
			throw new Error("The tested element was not part of a party.");
		}
	}
	// move chars around
	var moveCharLeft = (char) => {
		if(char.previousElementSibling == null) return;
		char.parentNode.insertBefore(char, char.previousElementSibling);
		var partyID = getPartyID(char);
		var i = 0;
		while ( (char = char.previousElementSibling) != null ) {
			i++;
		}
		var j = parties[partyIndex.indexOf(partyID)].chars;
		j.splice(i, 0, j.splice(i + 1, 1)[0]);
		if(partiesCharsIndex[partyID].length == 4) checkCombos(partyID);
		savePartyData();
	}
	var moveCharRight = (char) => {
		if(char.nextElementSibling.nextElementSibling == null || char.nextElementSibling.classList.contains("partyAddChar")) return;
		char.parentNode.insertBefore(char, char.nextElementSibling.nextElementSibling);
		var partyID = getPartyID(char);
		var i = char.parentNode.childElementCount - 1;
		while ((char = char.nextElementSibling) != null) {
			i--;
		}
		var j = parties[partyIndex.indexOf(partyID)].chars;
		j.splice(i, 0, j.splice(i - 1, 1)[0]);
		if(partiesCharsIndex[partyID].length == 4) checkCombos(partyID);
		savePartyData();
	}
	// remove character
	// the remove could potentially be changed for a "swap character in place of this"?
	var removeChar = (char) => {
		var partyID = getPartyID(char);
		if(char.parentNode.childElementCount == 5) {
			get(char.parentNode.id.slice(0,7)+"-addChar").classList.remove("partyFull");
			get(partyID+"-combos").innerHTML = "";
		}
		var parentChildNodes = char.parentNode.childNodes;
		var i = 0;
		for (i; i < parentChildNodes.length; i++) {
			if(char === parentChildNodes[i]) break;
		}
		var j = parties[partyIndex.indexOf(partyID)].chars;
		j.splice(i,1);
		char.outerHTML = "";
		savePartyData();
	}
	
	// update party format
	var updateParties = () => {
		console.warn("Party Data does not match current version.");
		var newPartyFormat = [];
		// Convert from sets within party to sets within chars, usedIn within weapons and artifacts. Default weapons will be skipped.
		if(getLSItem("partiesVersion") == undefined) {
			// Previous data format is as follows
			// [ {id: $partyID, name: $partyName, ?note: $partyNote, chars: [ {name: $charName, note: $note, ?type: $travType, weapon: $weaponName, artifacts:[ {set: $artifactSet} (repeat per artifact, index is artifactType) ]} (repeat per character) ]} (repeat per party) ]
			
			// console.log("PreviousData",parties);
			for (var i in parties) {
				let party = parties[i];
				let partyID = createID("party",7,(party.id!=undefined?party.id:null));
				let partyName = party.name != undefined ? party.name : "Party "+partyID;
				let partyNote = party.note != undefined ? party.note : undefined;
				if(party.chars == undefined || !Array.isArray(party.chars) || (Array.isArray(party.chars) && party.chars.length == 0) ) continue; // skip empty parties
				let partyObj = {};
				partyObj.id = partyID;
				partyObj.name = partyName;
				if(partyNote != undefined) partyObj.note = partyNote;

				// go through each character
				partyObj.chars = [];
				for(let i in party.chars) {
					let char = party.chars[i];
					if(char.name == undefined) continue; // an empty character is not good. Skip it~
					let charName = char.name;
					let charObj = {name: charName};
					if(char.note != undefined) charObj.note = char.note;
					if(charName == "Traveler" && char.type != undefined) charObj.type = char.type; // "Anemo" is default type.
					var isWeaponDefault = true, emptyArtis = true;
					var setObj = {};
					var setID = "";
					// create weapon stuff - skip default weapons
					if(char.weapon != defaultWeapons[charDB[charName].weapon]) {
						isWeaponDefault = false;
						setID = createID("set--"+charName);
						var lsItem = parseLSItem(char.weapon,[]);
						
						var weapObj = {};
						var weapID = createID("weap--"+char.weapon);
						// since no information about exp or refinement was previously stored, they'll not be set.
						weapObj.id = weapID;
						setObj.weapon = weapID;
						if(weapObj.usedIn == undefined) weapObj.usedIn = {};
						weapObj.usedIn[charName] = [setID];
						lsItem.push(weapObj);
						setLSItem(char.weapon,JSON.stringify(lsItem));
						// console.info("weapObj for",charName,"is",weapObj,". lsitem is",lsItem);
					}
					// create artifact stuffs - skip empty stuff
					if(!(JSON.stringify(char.artifacts) == "[{},{},{},{},{}]" || char.artifacts == "[{},{},{},{},{}]")) {
						var artis;
						// for some reason i decided it would be a good idea to store artifacts as a stringified array.
						if(typeof(char.artifacts) == "string") {
							try {
								artis = JSON.parse(char.artifacts);
								emptyArtis = false;
							}
							catch {
								console.error("Artifacts for "+charName+" could not be parsed. Below is the string for them. Aborting.");
								// console.info(char.artifacts);
							}
						} else {
							artis = char.artifacts;
							emptyArtis = false;
						}
						if(!emptyArtis) {
							if(setID == "") setID = createID("set--"+charName);
							setObj.artifacts = [];
							// {set:$set} => $id or null for empty
							for(let j = 0; j < artis.length; j++) {
								// much like weapons, no stat info was declared with parties. best assume minimum stuff and no main stat or substats.
								let arti = artis[j];
								// check if empty or unknown set; if so push null and skip
								if(JSON.stringify(arti) == "{}" || artifactDB[arti.set] == undefined) {
									setObj.artifacts.push(null);
									continue;
								}
								if(allArtifactGroupsWithOneType.indexOf(arti.set) == -1) {
									// most sets would fall under this
									let artiType = artifactTypes[j];
									var lsItem = parseLSItem(arti.set,{});
									
									if(lsItem[artiType] == undefined) lsItem[artiType] = [];
									var artiObj = {};
									var artiID = createID("arti--"+arti.set+"--"+artiType);
									artiObj.id = artiID;
									artiObj.rarity = artifactDB[arti.set].rarityMin;
									if(artiObj.usedIn==undefined) artiObj.usedIn = {};
									artiObj.usedIn[charName] = setID;
									setObj.artifacts.push(artiID);
									lsItem[artiType].push(artiObj);
									setLSItem(arti.set,JSON.stringify(lsItem));
									// console.info("artiObj [", j, "] for", charName, "is", artiObj, ". lsitem is", lsItem);
								} else {
									// usually just the "Prayers..." sets
									var lsItem = parseLSItem(arti.set,[]);

									var artiObj = {};
									var artiID = createID("arti--"+arti.set);
									artiObj.id = artiID;
									artiObj.rarity = artifactDB[arti.set].rarityMin;
									if(artiObj.usedIn==undefined) artiObj.usedIn = {};
									artiObj.usedIn[charName] = setID;
									setObj.artifacts.push(artiID);
									lsItem.push(artiObj);
									setLSItem(arti.set,JSON.stringify(lsItem));
									// console.info("artiObj [",j,"] for", charName, "is", artiObj, ". lsitem is", lsItem);
								}
							}
						}
					}
					// apply set to character
					if(JSON.stringify(setObj) != "{}" && setID != "") {
						charObj.set = setID;
						setObj.id = setID;
						lsItem = parseLSItem(charName,{});

						if(lsItem.sets == undefined) lsItem.sets = [];
						lsItem.sets.push(setObj);
						setLSItem(charName,JSON.stringify(lsItem));
						// console.info("setObj for",charName,"is",setObj,". lsItem is",lsItem);
					}
					// add character to party
					partyObj.chars.push(charObj);
				}

				newPartyFormat.push(partyObj);
				// console.info("parsed data is",partyObj);
			}
			setLSItem("parties",JSON.stringify(newPartyFormat));
			// console.info(newPartyFormat)
		}
		setLSItem("partiesVersion",partiesVersion);
		loadCharacterIDs();
		hideWarning();
		return newPartyFormat;
	}
	</script>
</html>